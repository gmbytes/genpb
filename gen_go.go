package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
)

// EKeyInfo holds information about an EKey enum value
type EKeyInfo struct {
	Name  string
	Value int32
	IsDsp bool // Whether this is a dispatch (dsp) key
}

// GenerateGo generates Go code
func GenerateGo(cfg *Config) error {
	// Parse proto files
	enumMap, err := parseEKeyEnum(filepath.Join(cfg.ProtoDir, "cmd.proto"))
	if err != nil {
		return fmt.Errorf("parse cmd.proto: %w", err)
	}

	reqMessages, err := parseMessages(filepath.Join(cfg.ProtoDir, "cmd_req.proto"))
	if err != nil {
		return fmt.Errorf("parse cmd_req.proto: %w", err)
	}

	rspMessages, err := parseMessages(filepath.Join(cfg.ProtoDir, "cmd_rsp.proto"))
	if err != nil {
		return fmt.Errorf("parse cmd_rsp.proto: %w", err)
	}

	dspMessages, err := parseMessages(filepath.Join(cfg.ProtoDir, "cmd_dsp.proto"))
	if err != nil {
		return fmt.Errorf("parse cmd_dsp.proto: %w", err)
	}

	// Generate Go files using protoc
	if err := generateProtocGo(cfg); err != nil {
		return fmt.Errorf("protoc: %w", err)
	}

	// Generate cmd.ext.go
	outputPath := filepath.Join(cfg.GoOutDir, "cmd.ext.go")
	if err := writeGoCmdExt(outputPath, enumMap, reqMessages, rspMessages, dspMessages); err != nil {
		return fmt.Errorf("write cmd.ext.go: %w", err)
	}

	fmt.Printf("Generated: %s\n", outputPath)

	vectorPath := filepath.Join(cfg.GoOutDir, "data.pb.vector.go")
	if err := writeGoVectorExt(vectorPath); err != nil {
		return fmt.Errorf("write data.pb.vector.go: %w", err)
	}

	fmt.Printf("Generated: %s\n", vectorPath)
	return nil
}

// generateProtocGo runs protoc to generate Go files
func generateProtocGo(cfg *Config) error {
	args := []string{
		"--go_out=" + cfg.GoOutDir,
		"--go_opt=paths=source_relative",
		fmt.Sprintf("--go_opt=Mpackage=%s", cfg.GoPkg),
		fmt.Sprintf("--plugin=protoc-gen-go=%s", cfg.ProtocGenGo),
		"-I" + cfg.ProtoDir,
		"-I" + cfg.GoOutDir,
	}

	protoFiles, err := filepath.Glob(filepath.Join(cfg.ProtoDir, "*.proto"))
	if err != nil {
		return fmt.Errorf("list proto files: %w", err)
	}

	// Filter proto files based on flag
	protoFiles = filterProtoFiles(protoFiles, cfg.Flag)

	args = append(args, protoFiles...)

	cmd := exec.Command(cfg.ProtocPath, args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	fmt.Printf("Running: %s %s\n", cfg.ProtocPath, strings.Join(args, " "))

	return cmd.Run()
}

// filterProtoFiles filters proto files based on flag
// server: export all files
// client: exclude data_srv.proto and data_fwd.proto
func filterProtoFiles(files []string, flag string) []string {
	if flag == "server" {
		return files
	}

	// client mode: exclude server-only files
	excludeFiles := map[string]bool{
		"data_srv.proto": true,
		"data_fwd.proto": true,
	}

	var filtered []string
	for _, f := range files {
		baseName := filepath.Base(f)
		if !excludeFiles[baseName] {
			filtered = append(filtered, f)
		}
	}
	return filtered
}

// writeGoCmdExt generates cmd.ext.go for Go
func writeGoCmdExt(path string, enumMap map[int32]EKeyInfo, reqMessages, rspMessages, dspMessages []string) error {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by pbgen. DO NOT EDIT.\n")
	buf.WriteString("// source: cmd.proto, cmd_req.proto, cmd_rsp.proto, cmd_dsp.proto\n\n")
	buf.WriteString("package pb\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"google.golang.org/protobuf/proto\"\n")
	buf.WriteString(")\n\n")

	// Global parser instance
	buf.WriteString("var _parser = NewParser()\n\n")
	buf.WriteString("func init() {\n")
	buf.WriteString("\t_parser.Load()\n")
	buf.WriteString("}\n\n")
	buf.WriteString("func Unmarshal(key EKey_T, data []byte) proto.Message {\n")
	buf.WriteString("\treturn _parser.Unmarshal(key, data)\n")
	buf.WriteString("}\n\n")

	// Parser struct
	buf.WriteString("// parser handles protobuf message parsing by EKey\n")
	buf.WriteString("type parser struct {\n")
	buf.WriteString("\ttypes map[EKey_T]func() proto.Message\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// NewParser creates a new Parser instance\n")
	buf.WriteString("func NewParser() *parser {\n")
	buf.WriteString("\treturn &parser{\n")
	buf.WriteString("\t\ttypes: make(map[EKey_T]func() proto.Message),\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// Register registers a message factory for a given EKey\n")
	buf.WriteString("func (p *parser) Register(key EKey_T, factory func() proto.Message) {\n")
	buf.WriteString("\tp.types[key] = factory\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// New creates a new message instance for the given EKey\n")
	buf.WriteString("func (p *parser) New(key EKey_T) proto.Message {\n")
	buf.WriteString("\tfactory, ok := p.types[key]\n")
	buf.WriteString("\tif !ok {\n")
	buf.WriteString("\t\treturn nil\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn factory()\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// Unmarshal unmarshals binary data into a new message instance\n")
	buf.WriteString("func (p *parser) Unmarshal(key EKey_T, data []byte) proto.Message {\n")
	buf.WriteString("\tmsg := p.New(key)\n")
	buf.WriteString("\tif msg == nil {\n")
	buf.WriteString("\t\treturn nil\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tif err := proto.Unmarshal(data, msg); err != nil {\n")
	buf.WriteString("\t\treturn nil\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn msg\n")
	buf.WriteString("}\n\n")

	// Load method
	buf.WriteString("// Load registers all message types\n")
	buf.WriteString("func (p *parser) Load() {\n")

	// Client-to-Server requests
	for _, msgName := range reqMessages {
		enumName := strings.TrimPrefix(msgName, "Req")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("\tp.Register(EKey_%s, func() proto.Message { return &%s{} })\n", info.Name, msgName))
				break
			}
		}
	}

	// Server-to-Client responses
	for _, msgName := range rspMessages {
		if strings.HasPrefix(msgName, "RspSync") {
			continue
		}
		enumName := strings.TrimPrefix(msgName, "Rsp")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("\tp.Register(EKey_%s, func() proto.Message { return &%s{} })\n", info.Name, msgName))
				break
			}
		}
	}

	// Server dispatch/sync messages (Dsp prefix)
	for _, msgName := range dspMessages {
		if !strings.HasPrefix(msgName, "Dsp") {
			continue
		}
		// enumName = name after "Dsp" (e.g., DspLoginFast -> LoginFast)
		enumName := strings.TrimPrefix(msgName, "Dsp")
		for _, info := range enumMap {
			if info.Name == enumName && info.IsDsp {
				buf.WriteString(fmt.Sprintf("\tp.Register(EKey_%s, func() proto.Message { return &%s{} })\n", info.Name, msgName))
				break
			}
		}
	}

	buf.WriteString("}\n\n")

	// Generate Key() methods for all messages
	// Client-to-Server requests
	for _, msgName := range reqMessages {
		enumName := strings.TrimPrefix(msgName, "Req")
		for _, info := range enumMap {
			if info.Name == enumName && !info.IsDsp {
				buf.WriteString(fmt.Sprintf("func (msg *%s) Key() EKey_T {\n", msgName))
				buf.WriteString(fmt.Sprintf("\treturn EKey_%s\n", info.Name))
				buf.WriteString("}\n\n")
				break
			}
		}
	}

	// Server-to-Client responses
	for _, msgName := range rspMessages {
		enumName := strings.TrimPrefix(msgName, "Rsp")
		for _, info := range enumMap {
			if info.Name == enumName && !info.IsDsp {
				buf.WriteString(fmt.Sprintf("func (msg *%s) Key() EKey_T {\n", msgName))
				buf.WriteString(fmt.Sprintf("\treturn EKey_%s\n", info.Name))
				buf.WriteString("}\n\n")
				break
			}
		}
	}

	// Server dispatch/sync messages (Dsp prefix)
	for _, msgName := range dspMessages {
		if !strings.HasPrefix(msgName, "Dsp") {
			continue
		}
		// enumName = name after "Dsp" (e.g., DspLoginFast -> LoginFast)
		enumName := strings.TrimPrefix(msgName, "Dsp")
		for _, info := range enumMap {
			if info.Name == enumName && info.IsDsp {
				buf.WriteString(fmt.Sprintf("func (msg *%s) Key() EKey_T {\n", msgName))
				buf.WriteString(fmt.Sprintf("\treturn EKey_%s\n", info.Name))
				buf.WriteString("}\n\n")
				break
			}
		}
	}

	return os.WriteFile(path, buf.Bytes(), 0644)
}

// parseEKeyEnum parses cmd.proto to extract EKey enum values
// Keys between "// dsp start" and "// dsp end" are marked as IsDsp=true
func parseEKeyEnum(path string) (map[int32]EKeyInfo, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	contentStr := string(content)
	result := make(map[int32]EKeyInfo)

	// Find dsp section boundaries
	dspStartIdx := strings.Index(contentStr, "// dsp start")
	dspEndIdx := strings.Index(contentStr, "// dsp end")

	pattern := regexp.MustCompile(`(\w+)\s*=\s*(\d+)\s*;`)
	matches := pattern.FindAllStringSubmatchIndex(contentStr, -1)

	for _, match := range matches {
		if len(match) >= 6 {
			name := contentStr[match[2]:match[3]]
			valueStr := contentStr[match[4]:match[5]]
			var value int32
			fmt.Sscanf(valueStr, "%d", &value)

			// Check if this key is in the dsp section
			isDsp := false
			if dspStartIdx >= 0 && dspEndIdx > dspStartIdx {
				keyPos := match[0]
				isDsp = keyPos > dspStartIdx && keyPos < dspEndIdx
			}

			result[value] = EKeyInfo{Name: name, Value: value, IsDsp: isDsp}
		}
	}

	return result, nil
}

// parseMessages parses a proto file to extract message names
func parseMessages(path string) ([]string, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var messages []string
	pattern := regexp.MustCompile(`message\s+(\w+)\s*\{`)
	matches := pattern.FindAllStringSubmatch(string(content), -1)

	for _, match := range matches {
		if len(match) == 2 {
			messages = append(messages, match[1])
		}
	}

	return messages, nil
}

func writeGoVectorExt(path string) error {
	content := `package pb

import (
	"fmt"
	"math"
	"math/rand/v2"
)

const (
	deg2Rad = math.Pi / 180
	rad2Deg = 180 / math.Pi
)

// X 轴为角色面朝，角色右手为Y，左手坐标系

var ZeroVector = &Vector{X: 0, Y: 0, Z: 0}
var ForwardVector = &Vector{X: 1, Y: 0, Z: 0}
var OneVector = &Vector{X: 1, Y: 1, Z: 1}

// NewVector 从 float64 创建一个向量（纯 float64，不再使用定点缩放）
func NewVector(x, y, z float64) *Vector {
	return &Vector{X: x, Y: y, Z: z}
}

// StringF 返回浮点格式的字符串表示（避免与 pb 生成的 String 冲突）
func (ss *Vector) StringF() string {
	return fmt.Sprintf("(%.5f, %.5f, %.5f)", ss.X, ss.Y, ss.Z)
}

// ToAngle2D 返回与 ForwardVector 在 XOY 平面的角度
func (ss *Vector) ToAngle2D() float64 {
	return ss.Angle2D(ForwardVector)
}

// Angle2D 返回与目标向量 XOY 平面的角度
func (ss *Vector) Angle2D(v *Vector) float64 {
	return ss.Radian2D(v) * rad2Deg
}

// ToRadian2D 返回与 ForwardVector 在 XOY 平面的弧度
func (ss *Vector) ToRadian2D() float64 {
	return ss.Radian2D(ForwardVector)
}

// Radian2D 返回与目标向量 XOY 平面的弧度
func (ss *Vector) Radian2D(v *Vector) float64 {
	sin := ss.X*v.Y - v.X*ss.Y
	cos := ss.X*v.X + ss.Y*v.Y
	return -math.Atan2(sin, cos)
}

// Rotate2D 返回绕 Z 轴旋转后的向量，单位为弧度，左手坐标系
func (ss *Vector) Rotate2D(alpha float64) *Vector {
	sinA, cosA := math.Sincos(alpha)
	return &Vector{
		X: ss.X*cosA - ss.Y*sinA,
		Y: ss.X*sinA + ss.Y*cosA,
		Z: ss.Z,
	}
}

// RotateAngle2D 返回绕 Z 轴旋转后的向量，单位为角度，左手坐标系
func (ss *Vector) RotateAngle2D(alphaDeg float64) *Vector {
	return ss.Rotate2D(alphaDeg * deg2Rad)
}

func (ss *Vector) Dot2D(v *Vector) float64 {
	return ss.X*v.X + ss.Y*v.Y
}

func (ss *Vector) Dot(v *Vector) float64 {
	return ss.X*v.X + ss.Y*v.Y + ss.Z*v.Z
}

func (ss *Vector) Cross(v *Vector) *Vector {
	return &Vector{
		X: ss.Y*v.Z - ss.Z*v.Y,
		Y: ss.Z*v.X - ss.X*v.Z,
		Z: ss.X*v.Y - ss.Y*v.X,
	}
}

func (ss *Vector) LengthSq2D() float64 {
	return ss.X*ss.X + ss.Y*ss.Y
}

func (ss *Vector) LengthSq() float64 {
	return ss.X*ss.X + ss.Y*ss.Y + ss.Z*ss.Z
}

func (ss *Vector) Length2D() float64 {
	return math.Sqrt(ss.LengthSq2D())
}

func (ss *Vector) Length() float64 {
	return math.Sqrt(ss.LengthSq())
}

func (ss *Vector) DistanceSq2D(v *Vector) float64 {
	dx, dy := ss.X-v.X, ss.Y-v.Y
	return dx*dx + dy*dy
}

func (ss *Vector) DistanceSq(v *Vector) float64 {
	dx, dy, dz := ss.X-v.X, ss.Y-v.Y, ss.Z-v.Z
	return dx*dx + dy*dy + dz*dz
}

func (ss *Vector) Distance2D(v *Vector) float64 {
	return math.Sqrt(ss.DistanceSq2D(v))
}

func (ss *Vector) Distance(v *Vector) float64 {
	return math.Sqrt(ss.DistanceSq(v))
}

func (ss *Vector) Equal2D(v *Vector) bool {
	return ss.X == v.X && ss.Y == v.Y
}

func (ss *Vector) Equal(v *Vector) bool {
	return ss.X == v.X && ss.Y == v.Y && ss.Z == v.Z
}

func (ss *Vector) ApproximatelyEqual2D(v *Vector) bool {
	return math.Abs(ss.X-v.X) < 1e-7 && math.Abs(ss.Y-v.Y) < 1e-7
}

func (ss *Vector) ApproximatelyEqual(v *Vector) bool {
	return math.Abs(ss.X-v.X) < 1e-7 && math.Abs(ss.Y-v.Y) < 1e-7 && math.Abs(ss.Z-v.Z) < 1e-7
}

func (ss *Vector) Orthogonal2D() *Vector {
	return &Vector{
		X: -ss.Y,
		Y: ss.X,
		Z: ss.Z,
	}
}

func (ss *Vector) Copy() *Vector {
	return &Vector{
		X: ss.X,
		Y: ss.Y,
		Z: ss.Z,
	}
}

func (ss *Vector) CopyNewZ(z float64) *Vector {
	return &Vector{
		X: ss.X,
		Y: ss.Y,
		Z: z,
	}
}

func (ss *Vector) CopyTo(dst *Vector) {
	dst.X = ss.X
	dst.Y = ss.Y
	dst.Z = ss.Z
}

func (ss *Vector) Reverse2D() *Vector {
	return &Vector{
		X: -ss.X,
		Y: -ss.Y,
		Z: ss.Z,
	}
}

func (ss *Vector) Reverse() *Vector {
	return &Vector{
		X: -ss.X,
		Y: -ss.Y,
		Z: -ss.Z,
	}
}

func (ss *Vector) Add2D(v *Vector) *Vector {
	return &Vector{
		X: ss.X + v.X,
		Y: ss.Y + v.Y,
		Z: ss.Z,
	}
}

func (ss *Vector) Add(v *Vector) *Vector {
	return &Vector{
		X: ss.X + v.X,
		Y: ss.Y + v.Y,
		Z: ss.Z + v.Z,
	}
}

func (ss *Vector) Sub2D(v *Vector) *Vector {
	return &Vector{
		X: ss.X - v.X,
		Y: ss.Y - v.Y,
		Z: ss.Z,
	}
}

func (ss *Vector) Sub(v *Vector) *Vector {
	return &Vector{
		X: ss.X - v.X,
		Y: ss.Y - v.Y,
		Z: ss.Z - v.Z,
	}
}

func (ss *Vector) Mul2D(v float64) *Vector {
	return &Vector{
		X: ss.X * v,
		Y: ss.Y * v,
		Z: ss.Z,
	}
}

func (ss *Vector) Mul(v float64) *Vector {
	return &Vector{
		X: ss.X * v,
		Y: ss.Y * v,
		Z: ss.Z * v,
	}
}

func (ss *Vector) Div2D(v float64) *Vector {
	if v == 0 {
		return ss.Copy()
	}
	inv := 1 / v
	return &Vector{
		X: ss.X * inv,
		Y: ss.Y * inv,
		Z: ss.Z,
	}
}

func (ss *Vector) Div(v float64) *Vector {
	if v == 0 {
		return ss.Copy()
	}
	inv := 1 / v
	return &Vector{
		X: ss.X * inv,
		Y: ss.Y * inv,
		Z: ss.Z * inv,
	}
}

func (ss *Vector) Norm2D() *Vector {
	lenSq := ss.LengthSq2D()
	if lenSq == 0 {
		return ForwardVector.Copy()
	}
	l := 1 / math.Sqrt(lenSq)
	return &Vector{
		X: ss.X * l,
		Y: ss.Y * l,
		Z: ss.Z,
	}
}

func (ss *Vector) Norm() *Vector {
	lenSq := ss.LengthSq()
	if lenSq == 0 {
		return ss.Copy()
	}
	if lenSq == 1 {
		return ss.Copy()
	}
	l := 1 / math.Sqrt(lenSq)
	return &Vector{
		X: ss.X * l,
		Y: ss.Y * l,
		Z: ss.Z * l,
	}
}

func GenerateRandomVector(min, max *Vector) *Vector {
	return &Vector{
		X: rand.Float64()*(max.X-min.X) + min.X,
		Y: rand.Float64()*(max.Y-min.Y) + min.Y,
		Z: rand.Float64()*(max.Z-min.Z) + min.Z,
	}
}
`

	return os.WriteFile(path, []byte(content), 0644)
}
