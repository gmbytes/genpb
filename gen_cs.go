package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
)

// EKeyInfo holds information about an EKey enum value
type CSEnumInfo struct {
	Name  string
	Value int32
}

// GenerateCSharp generates C# code
func GenerateCSharp(cfg *Config) error {
	// Parse proto files
	enumMap, err := parseCSEKeyEnum(filepath.Join(cfg.ProtoDir, "cmd.proto"))
	if err != nil {
		return fmt.Errorf("parse cmd.proto: %w", err)
	}

	reqMessages, err := parseCSMessages(filepath.Join(cfg.ProtoDir, "cmd_req.proto"))
	if err != nil {
		return fmt.Errorf("parse cmd_req.proto: %w", err)
	}

	rspMessages, err := parseCSMessages(filepath.Join(cfg.ProtoDir, "cmd_rsp.proto"))
	if err != nil {
		return fmt.Errorf("parse cmd_rsp.proto: %w", err)
	}

	dspMessages, err := parseCSMessages(filepath.Join(cfg.ProtoDir, "cmd_dsp.proto"))
	if err != nil {
		return fmt.Errorf("parse cmd_dsp.proto: %w", err)
	}

	// Generate C# proto files using protoc
	if err := generateProtocCSharp(cfg); err != nil {
		return fmt.Errorf("protoc csharp: %w", err)
	}

	// Generate CmdExt.cs (same directory as protoc C# output)
	outputPath := filepath.Join(cfg.CsOutDir, "CmdExt.cs")
	if err := writeCSCmd(outputPath, enumMap, reqMessages, rspMessages, dspMessages); err != nil {
		return fmt.Errorf("write CmdExt.cs: %w", err)
	}

	fmt.Printf("Generated: %s\n", outputPath)
	return nil
}

// generateProtocCSharp runs protoc to generate C# files
func generateProtocCSharp(cfg *Config) error {
	args := []string{
		"--csharp_out=" + cfg.CsOutDir,
		"-I" + cfg.ProtoDir,
	}

	protoFiles, err := filepath.Glob(filepath.Join(cfg.ProtoDir, "*.proto"))
	if err != nil {
		return fmt.Errorf("list proto files: %w", err)
	}

	args = append(args, protoFiles...)

	cmd := exec.Command(cfg.ProtocPath, args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	fmt.Printf("Running: %s %s\n", cfg.ProtocPath, strings.Join(args, " "))

	return cmd.Run()
}

// parseCSEKeyEnum parses cmd.proto to extract EKey enum values
func parseCSEKeyEnum(path string) (map[int32]CSEnumInfo, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	result := make(map[int32]CSEnumInfo)
	pattern := regexp.MustCompile(`(\w+)\s*=\s*(\d+)\s*;`)
	matches := pattern.FindAllStringSubmatch(string(content), -1)

	for _, match := range matches {
		if len(match) == 3 {
			name := match[1]
			var value int32
			fmt.Sscanf(match[2], "%d", &value)
			result[value] = CSEnumInfo{Name: name, Value: value}
		}
	}

	return result, nil
}

// parseCSMessages parses a proto file to extract message names
func parseCSMessages(path string) ([]string, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var messages []string
	pattern := regexp.MustCompile(`message\s+(\w+)\s*\{`)
	matches := pattern.FindAllStringSubmatch(string(content), -1)

	for _, match := range matches {
		if len(match) == 2 {
			messages = append(messages, match[1])
		}
	}

	return messages, nil
}

// writeCSCmd generates Cmd.cs for C#
func writeCSCmd(path string, enumMap map[int32]CSEnumInfo, reqMessages, rspMessages, dspMessages []string) error {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by pbgen. DO NOT EDIT.\n")
	buf.WriteString("// source: cmd.proto, cmd_req.proto, cmd_rsp.proto, cmd_dsp.proto\n\n")
	buf.WriteString("namespace Pb\n")
	buf.WriteString("{\n")
	buf.WriteString("    public partial class Cmd\n")
	buf.WriteString("    {\n")
	buf.WriteString("        /// <summary>\n")
	buf.WriteString("        /// Command keys enumeration\n")
	buf.WriteString("        /// </summary>\n")
	buf.WriteString("        public enum EKey\n")
	buf.WriteString("        {\n")

	// Generate enum values
	type EnumEntry struct {
		value int32
		info  CSEnumInfo
	}
	var enumValues []EnumEntry
	for v, info := range enumMap {
		enumValues = append(enumValues, EnumEntry{value: v, info: info})
	}

	// Sort by value
	for i := 0; i < len(enumValues)-1; i++ {
		for j := i + 1; j < len(enumValues); j++ {
			if enumValues[i].value > enumValues[j].value {
				enumValues[i], enumValues[j] = enumValues[j], enumValues[i]
			}
		}
	}

	for _, e := range enumValues {
		if e.value == 0 || e.value == 65535 {
			continue
		}
		buf.WriteString(fmt.Sprintf("            %s = %d,\n", e.info.Name, e.value))
	}

	buf.WriteString("        }\n")
	buf.WriteString("    }\n")
	buf.WriteString("}\n\n")

	// Generate message helper class
	buf.WriteString("namespace Pb\n")
	buf.WriteString("{\n")
	buf.WriteString("    public partial class Cmd\n")
	buf.WriteString("    {\n")
	buf.WriteString("        /// <summary>\n")
	buf.WriteString("        /// Get message type from command key\n")
	buf.WriteString("        /// </summary>\n")
	buf.WriteString("        public static System.Type GetMessageType(EKey key)\n")
	buf.WriteString("        {\n")
	buf.WriteString("            switch (key)\n")
	buf.WriteString("            {\n")

	// Client-to-Server requests
	for _, msgName := range reqMessages {
		enumName := strings.TrimPrefix(msgName, "Req")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("                case EKey.%s:\n", info.Name))
				buf.WriteString(fmt.Sprintf("                    return typeof(%s);\n", msgName))
				break
			}
		}
	}

	// Server-to-Client responses
	for _, msgName := range rspMessages {
		if strings.HasPrefix(msgName, "RspSync") {
			continue
		}
		enumName := strings.TrimPrefix(msgName, "Rsp")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("                case EKey.%s:\n", info.Name))
				buf.WriteString(fmt.Sprintf("                    return typeof(%s);\n", msgName))
				break
			}
		}
	}

	// Server dispatch/sync messages
	for _, msgName := range dspMessages {
		if !strings.HasPrefix(msgName, "RspSync") {
			continue
		}
		// enumName = "Sync" + name after "RspSync"
		enumName := "Sync" + strings.TrimPrefix(msgName, "RspSync")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("                case EKey.%s:\n", info.Name))
				buf.WriteString(fmt.Sprintf("                    return typeof(%s);\n", msgName))
				break
			}
		}
	}

	buf.WriteString("                default:\n")
	buf.WriteString("                    return null;\n")
	buf.WriteString("            }\n")
	buf.WriteString("        }\n")
	buf.WriteString("    }\n")
	buf.WriteString("}\n\n")

	// Generate message extension methods with Key property
	buf.WriteString("namespace Pb\n")
	buf.WriteString("{\n")
	buf.WriteString("    public static class CmdExtensions\n")
	buf.WriteString("    {\n")

	// Client-to-Server requests
	for _, msgName := range reqMessages {
		enumName := strings.TrimPrefix(msgName, "Req")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("        public static Cmd.EKey GetKey(this %s msg)\n", msgName))
				buf.WriteString("        {\n")
				buf.WriteString(fmt.Sprintf("            return Cmd.EKey.%s;\n", info.Name))
				buf.WriteString("        }\n\n")
				break
			}
		}
	}

	// Server-to-Client responses
	for _, msgName := range rspMessages {
		if strings.HasPrefix(msgName, "RspSync") {
			continue
		}
		enumName := strings.TrimPrefix(msgName, "Rsp")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("        public static Cmd.EKey GetKey(this %s msg)\n", msgName))
				buf.WriteString("        {\n")
				buf.WriteString(fmt.Sprintf("            return Cmd.EKey.%s;\n", info.Name))
				buf.WriteString("        }\n\n")
				break
			}
		}
	}

	// Server dispatch/sync messages
	for _, msgName := range dspMessages {
		if !strings.HasPrefix(msgName, "RspSync") {
			continue
		}
		// enumName = "Sync" + name after "RspSync"
		enumName := "Sync" + strings.TrimPrefix(msgName, "RspSync")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("        public static Cmd.EKey GetKey(this %s msg)\n", msgName))
				buf.WriteString("        {\n")
				buf.WriteString(fmt.Sprintf("            return Cmd.EKey.%s;\n", info.Name))
				buf.WriteString("        }\n\n")
				break
			}
		}
	}

	buf.WriteString("    }\n")
	buf.WriteString("}\n")

	return os.WriteFile(path, buf.Bytes(), 0644)
}
