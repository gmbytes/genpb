package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
)

// CSEnumInfo holds information about an EKey enum value
type CSEnumInfo struct {
	Name  string
	Value int32
	IsDsp bool // Whether this is a dispatch (dsp) key
}

// GenerateCSharp generates C# code
func GenerateCSharp(cfg *Config) error {
	// Parse proto files
	enumMap, err := parseCSEKeyEnum(filepath.Join(cfg.ProtoDir, "cmd.proto"))
	if err != nil {
		return fmt.Errorf("parse cmd.proto: %w", err)
	}

	reqMessages, err := parseCSMessages(filepath.Join(cfg.ProtoDir, "cmd_req.proto"))
	if err != nil {
		return fmt.Errorf("parse cmd_req.proto: %w", err)
	}

	rspMessages, err := parseCSMessages(filepath.Join(cfg.ProtoDir, "cmd_rsp.proto"))
	if err != nil {
		return fmt.Errorf("parse cmd_rsp.proto: %w", err)
	}

	dspMessages, err := parseCSMessages(filepath.Join(cfg.ProtoDir, "cmd_dsp.proto"))
	if err != nil {
		return fmt.Errorf("parse cmd_dsp.proto: %w", err)
	}

	// Generate C# proto files using protoc
	if err := generateProtocCSharp(cfg); err != nil {
		return fmt.Errorf("protoc csharp: %w", err)
	}

	// Generate CmdExt.cs (same directory as protoc C# output)
	outputPath := filepath.Join(cfg.CsOutDir, "CmdExt.cs")
	if err := writeCSCmd(outputPath, enumMap, reqMessages, rspMessages, dspMessages); err != nil {
		return fmt.Errorf("write CmdExt.cs: %w", err)
	}

	fmt.Printf("Generated: %s\n", outputPath)

	vectorPath := filepath.Join(cfg.CsOutDir, "DataVector.cs")
	if err := writeCSVectorExt(vectorPath); err != nil {
		return fmt.Errorf("write DataVector.cs: %w", err)
	}

	fmt.Printf("Generated: %s\n", vectorPath)
	return nil
}

// generateProtocCSharp runs protoc to generate C# files
func generateProtocCSharp(cfg *Config) error {
	args := []string{
		"--csharp_out=" + cfg.CsOutDir,
		"-I" + cfg.ProtoDir,
	}

	protoFiles, err := filepath.Glob(filepath.Join(cfg.ProtoDir, "*.proto"))
	if err != nil {
		return fmt.Errorf("list proto files: %w", err)
	}

	// Filter proto files based on flag
	protoFiles = filterCSProtoFiles(protoFiles, cfg.Flag)

	args = append(args, protoFiles...)

	cmd := exec.Command(cfg.ProtocPath, args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	fmt.Printf("Running: %s %s\n", cfg.ProtocPath, strings.Join(args, " "))

	return cmd.Run()
}

// filterCSProtoFiles filters proto files based on flag
// server: export all files
// client: exclude data_srv.proto and data_fwd.proto
func filterCSProtoFiles(files []string, flag string) []string {
	if flag == "server" {
		return files
	}

	// client mode: exclude server-only files
	excludeFiles := map[string]bool{
		"data_srv.proto": true,
		"data_fwd.proto": true,
	}

	var filtered []string
	for _, f := range files {
		baseName := filepath.Base(f)
		if !excludeFiles[baseName] {
			filtered = append(filtered, f)
		}
	}
	return filtered
}

// parseCSEKeyEnum parses cmd.proto to extract EKey enum values
// Keys between "// dsp start" and "// dsp end" are marked as IsDsp=true
func parseCSEKeyEnum(path string) (map[int32]CSEnumInfo, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	contentStr := string(content)
	result := make(map[int32]CSEnumInfo)

	// Find dsp section boundaries
	dspStartIdx := strings.Index(contentStr, "// dsp start")
	dspEndIdx := strings.Index(contentStr, "// dsp end")

	pattern := regexp.MustCompile(`(\w+)\s*=\s*(\d+)\s*;`)
	matches := pattern.FindAllStringSubmatchIndex(contentStr, -1)

	for _, match := range matches {
		if len(match) >= 6 {
			name := contentStr[match[2]:match[3]]
			valueStr := contentStr[match[4]:match[5]]
			var value int32
			fmt.Sscanf(valueStr, "%d", &value)

			// Check if this key is in the dsp section
			isDsp := false
			if dspStartIdx >= 0 && dspEndIdx > dspStartIdx {
				keyPos := match[0]
				isDsp = keyPos > dspStartIdx && keyPos < dspEndIdx
			}

			result[value] = CSEnumInfo{Name: name, Value: value, IsDsp: isDsp}
		}
	}

	return result, nil
}

// parseCSMessages parses a proto file to extract message names
func parseCSMessages(path string) ([]string, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var messages []string
	pattern := regexp.MustCompile(`message\s+(\w+)\s*\{`)
	matches := pattern.FindAllStringSubmatch(string(content), -1)

	for _, match := range matches {
		if len(match) == 2 {
			messages = append(messages, match[1])
		}
	}

	return messages, nil
}

// writeCSCmd generates Cmd.Pb for C#
func writeCSCmd(path string, enumMap map[int32]CSEnumInfo, reqMessages, rspMessages, dspMessages []string) error {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by pbgen. DO NOT EDIT.\n")
	buf.WriteString("// source: cmd.proto, cmd_req.proto, cmd_rsp.proto, cmd_dsp.proto\n\n")
	buf.WriteString("namespace Pb\n")
	buf.WriteString("{\n")
	buf.WriteString("    public partial class Cmd\n")
	buf.WriteString("    {\n")
	buf.WriteString("        /// <summary>\n")
	buf.WriteString("        /// Command keys enumeration\n")
	buf.WriteString("        /// </summary>\n")
	buf.WriteString("        public enum EKey\n")
	buf.WriteString("        {\n")

	// Generate enum values
	type EnumEntry struct {
		value int32
		info  CSEnumInfo
	}
	var enumValues []EnumEntry
	for v, info := range enumMap {
		enumValues = append(enumValues, EnumEntry{value: v, info: info})
	}

	// Sort by value
	for i := 0; i < len(enumValues)-1; i++ {
		for j := i + 1; j < len(enumValues); j++ {
			if enumValues[i].value > enumValues[j].value {
				enumValues[i], enumValues[j] = enumValues[j], enumValues[i]
			}
		}
	}

	for _, e := range enumValues {
		if e.value == 0 || e.value == 65535 {
			continue
		}
		buf.WriteString(fmt.Sprintf("            %s = %d,\n", e.info.Name, e.value))
	}

	buf.WriteString("        }\n")
	buf.WriteString("    }\n")
	buf.WriteString("}\n\n")

	// Generate message helper class
	buf.WriteString("namespace Pb\n")
	buf.WriteString("{\n")
	buf.WriteString("    public partial class Cmd\n")
	buf.WriteString("    {\n")
	buf.WriteString("        /// <summary>\n")
	buf.WriteString("        /// Get message type from command key\n")
	buf.WriteString("        /// </summary>\n")
	buf.WriteString("        public static System.Type GetMessageType(EKey key)\n")
	buf.WriteString("        {\n")
	buf.WriteString("            switch (key)\n")
	buf.WriteString("            {\n")

	// Client-to-Server requests
	for _, msgName := range reqMessages {
		enumName := strings.TrimPrefix(msgName, "Req")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("                case EKey.%s:\n", info.Name))
				buf.WriteString(fmt.Sprintf("                    return typeof(%s);\n", msgName))
				break
			}
		}
	}

	// Server-to-Client responses
	for _, msgName := range rspMessages {
		if strings.HasPrefix(msgName, "RspSync") {
			continue
		}
		enumName := strings.TrimPrefix(msgName, "Rsp")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("                case EKey.%s:\n", info.Name))
				buf.WriteString(fmt.Sprintf("                    return typeof(%s);\n", msgName))
				break
			}
		}
	}

	// Server dispatch/sync messages (Dsp prefix)
	for _, msgName := range dspMessages {
		if !strings.HasPrefix(msgName, "Dsp") {
			continue
		}
		// enumName = name after "Dsp" (e.g., DspLoginFast -> LoginFast)
		enumName := strings.TrimPrefix(msgName, "Dsp")
		for _, info := range enumMap {
			if info.Name == enumName && info.IsDsp {
				buf.WriteString(fmt.Sprintf("                case EKey.%s:\n", info.Name))
				buf.WriteString(fmt.Sprintf("                    return typeof(%s);\n", msgName))
				break
			}
		}
	}

	buf.WriteString("                default:\n")
	buf.WriteString("                    return null;\n")
	buf.WriteString("            }\n")
	buf.WriteString("        }\n")
	buf.WriteString("    }\n")
	buf.WriteString("}\n\n")

	// Generate message extension methods with Key property
	buf.WriteString("namespace Pb\n")
	buf.WriteString("{\n")
	buf.WriteString("    public static class CmdExtensions\n")
	buf.WriteString("    {\n")

	// Client-to-Server requests
	for _, msgName := range reqMessages {
		enumName := strings.TrimPrefix(msgName, "Req")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("        public static Cmd.EKey GetKey(this %s msg)\n", msgName))
				buf.WriteString("        {\n")
				buf.WriteString(fmt.Sprintf("            return Cmd.EKey.%s;\n", info.Name))
				buf.WriteString("        }\n\n")
				break
			}
		}
	}

	// Server-to-Client responses
	for _, msgName := range rspMessages {
		if strings.HasPrefix(msgName, "RspSync") {
			continue
		}
		enumName := strings.TrimPrefix(msgName, "Rsp")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("        public static Cmd.EKey GetKey(this %s msg)\n", msgName))
				buf.WriteString("        {\n")
				buf.WriteString(fmt.Sprintf("            return Cmd.EKey.%s;\n", info.Name))
				buf.WriteString("        }\n\n")
				break
			}
		}
	}

	// Server dispatch/sync messages (Dsp prefix)
	for _, msgName := range dspMessages {
		if !strings.HasPrefix(msgName, "Dsp") {
			continue
		}
		// enumName = name after "Dsp" (e.g., DspLoginFast -> LoginFast)
		enumName := strings.TrimPrefix(msgName, "Dsp")
		for _, info := range enumMap {
			if info.Name == enumName && info.IsDsp {
				buf.WriteString(fmt.Sprintf("        public static Cmd.EKey GetKey(this %s msg)\n", msgName))
				buf.WriteString("        {\n")
				buf.WriteString(fmt.Sprintf("            return Cmd.EKey.%s;\n", info.Name))
				buf.WriteString("        }\n\n")
				break
			}
		}
	}

	buf.WriteString("    }\n")
	buf.WriteString("}\n")

	return os.WriteFile(path, buf.Bytes(), 0644)
}

func writeCSVectorExt(path string) error {
	content := `// Code generated by pbgen. DO NOT EDIT.
// source: data.proto

using System;

namespace Pb
{
    public sealed partial class Vector
    {
        // ==================== 定点数常量 ====================

        /// <summary>定点数放大倍率。真实坐标 0.001 对应 long 值 1。</summary>
        public const long Scale = 1000;
        public const double ScaleF64 = 1000.0;

        private static readonly double Deg2Rad = Math.PI / 180.0;
        private static readonly double Rad2Deg = 180.0 / Math.PI;
        private static readonly Random RandomSource = new Random();

        // X 轴为角色面朝，角色右手为Y，左手坐标系

        public static readonly Vector ZeroVector = new Vector { X = 0, Y = 0, Z = 0 };
        public static readonly Vector ForwardVector = new Vector { X = Scale, Y = 0, Z = 0 };
        public static readonly Vector OneVector = new Vector { X = Scale, Y = Scale, Z = Scale };

        // ==================== 构造 / 转换 ====================

        /// <summary>从真实浮点坐标创建定点数向量（自动 ×Scale）</summary>
        public static Vector NewVector(double x, double y, double z)
        {
            return new Vector
            {
                X = FloatToFixed(x),
                Y = FloatToFixed(y),
                Z = FloatToFixed(z)
            };
        }

        /// <summary>直接从定点数整数值创建向量（不做缩放）</summary>
        public static Vector NewVectorInt(long x, long y, long z)
        {
            return new Vector { X = x, Y = y, Z = z };
        }

        /// <summary>将真实浮点数转为定点数（×Scale，四舍五入）</summary>
        public static long FloatToFixed(double f)
        {
            return (long)Math.Round(f * ScaleF64);
        }

        /// <summary>将定点数转为真实浮点数（÷Scale）</summary>
        public static double FixedToFloat(long v)
        {
            return (double)v / ScaleF64;
        }

        /// <summary>返回真实浮点坐标 (x, y, z)</summary>
        public void ToFloat64(out double ox, out double oy, out double oz)
        {
            ox = FixedToFloat(X);
            oy = FixedToFloat(Y);
            oz = FixedToFloat(Z);
        }

        /// <summary>返回 X 的真实浮点值</summary>
        public double Xf() { return FixedToFloat(X); }

        /// <summary>返回 Y 的真实浮点值</summary>
        public double Yf() { return FixedToFloat(Y); }

        /// <summary>返回 Z 的真实浮点值</summary>
        public double Zf() { return FixedToFloat(Z); }

        // ==================== 字符串 ====================

        /// <summary>返回真实浮点坐标的字符串表示</summary>
        public string StringF()
        {
            return string.Format("({0:F3}, {1:F3}, {2:F3})", Xf(), Yf(), Zf());
        }

        // ==================== 角度 / 弧度 ====================

        /// <summary>返回与 ForwardVector 在 XOY 平面的角度</summary>
        public double ToAngle2D()
        {
            return Angle2D(ForwardVector);
        }

        /// <summary>返回与目标向量 XOY 平面的角度</summary>
        public double Angle2D(Vector v)
        {
            return Radian2D(v) * Rad2Deg;
        }

        /// <summary>返回与 ForwardVector 在 XOY 平面的弧度</summary>
        public double ToRadian2D()
        {
            return Radian2D(ForwardVector);
        }

        /// <summary>返回与目标向量 XOY 平面的弧度</summary>
        public double Radian2D(Vector v)
        {
            double sin = (double)X * (double)v.Y - (double)v.X * (double)Y;
            double cos = (double)X * (double)v.X + (double)Y * (double)v.Y;
            return -Math.Atan2(sin, cos);
        }

        // ==================== 旋转 ====================

        /// <summary>返回绕 Z 轴旋转后的向量，单位为弧度，左手坐标系</summary>
        public Vector Rotate2D(double alpha)
        {
            double sinA = Math.Sin(alpha);
            double cosA = Math.Cos(alpha);
            double fx = (double)X, fy = (double)Y;
            return new Vector
            {
                X = (long)Math.Round(fx * cosA - fy * sinA),
                Y = (long)Math.Round(fx * sinA + fy * cosA),
                Z = Z
            };
        }

        /// <summary>返回绕 Z 轴旋转后的向量，单位为角度，左手坐标系</summary>
        public Vector RotateAngle2D(double alphaDeg)
        {
            return Rotate2D(alphaDeg * Deg2Rad);
        }

        // ==================== 点乘 / 叉乘 ====================

        /// <summary>返回二维点积（定点数结果，值为真实点积 × Scale²）</summary>
        public long Dot2D(Vector v)
        {
            return X * v.X + Y * v.Y;
        }

        /// <summary>返回二维点积的真实浮点值</summary>
        public double Dot2DFloat(Vector v)
        {
            return (double)Dot2D(v) / (ScaleF64 * ScaleF64);
        }

        /// <summary>返回三维点积（定点数结果，值为真实点积 × Scale²）</summary>
        public long Dot(Vector v)
        {
            return X * v.X + Y * v.Y + Z * v.Z;
        }

        /// <summary>返回三维点积的真实浮点值</summary>
        public double DotFloat(Vector v)
        {
            return (double)Dot(v) / (ScaleF64 * ScaleF64);
        }

        /// <summary>返回三维叉积（定点数结果，注意缩放关系：结果值 = 真实叉积 × Scale²）</summary>
        public Vector Cross(Vector v)
        {
            return new Vector
            {
                X = (Y * v.Z - Z * v.Y) / Scale,
                Y = (Z * v.X - X * v.Z) / Scale,
                Z = (X * v.Y - Y * v.X) / Scale
            };
        }

        // ==================== 长度 ====================

        /// <summary>返回二维长度的平方（定点数域，值 = 真实长度² × Scale²）</summary>
        public long LengthSq2D()
        {
            return X * X + Y * Y;
        }

        /// <summary>返回三维长度的平方（定点数域，值 = 真实长度² × Scale²）</summary>
        public long LengthSq()
        {
            return X * X + Y * Y + Z * Z;
        }

        /// <summary>返回二维长度平方的真实浮点值</summary>
        public double LengthSq2DFloat()
        {
            return (double)LengthSq2D() / (ScaleF64 * ScaleF64);
        }

        /// <summary>返回三维长度平方的真实浮点值</summary>
        public double LengthSqFloat()
        {
            return (double)LengthSq() / (ScaleF64 * ScaleF64);
        }

        /// <summary>返回二维长度的真实浮点值</summary>
        public double Length2D()
        {
            return Math.Sqrt((double)LengthSq2D()) / ScaleF64;
        }

        /// <summary>返回三维长度的真实浮点值</summary>
        public double Length()
        {
            return Math.Sqrt((double)LengthSq()) / ScaleF64;
        }

        // ==================== 距离 ====================

        /// <summary>返回二维距离的平方（定点数域）</summary>
        public long DistanceSq2D(Vector v)
        {
            long dx = X - v.X, dy = Y - v.Y;
            return dx * dx + dy * dy;
        }

        /// <summary>返回三维距离的平方（定点数域）</summary>
        public long DistanceSq(Vector v)
        {
            long dx = X - v.X, dy = Y - v.Y, dz = Z - v.Z;
            return dx * dx + dy * dy + dz * dz;
        }

        /// <summary>返回二维距离平方的真实浮点值</summary>
        public double DistanceSq2DFloat(Vector v)
        {
            return (double)DistanceSq2D(v) / (ScaleF64 * ScaleF64);
        }

        /// <summary>返回三维距离平方的真实浮点值</summary>
        public double DistanceSqFloat(Vector v)
        {
            return (double)DistanceSq(v) / (ScaleF64 * ScaleF64);
        }

        /// <summary>返回二维距离的真实浮点值</summary>
        public double Distance2D(Vector v)
        {
            return Math.Sqrt((double)DistanceSq2D(v)) / ScaleF64;
        }

        /// <summary>返回三维距离的真实浮点值</summary>
        public double Distance(Vector v)
        {
            return Math.Sqrt((double)DistanceSq(v)) / ScaleF64;
        }

        // ==================== 相等比较 ====================

        /// <summary>判断 XY 是否完全相等</summary>
        public bool Equal2D(Vector v)
        {
            return X == v.X && Y == v.Y;
        }

        /// <summary>判断 XYZ 是否完全相等</summary>
        public bool Equal(Vector v)
        {
            return X == v.X && Y == v.Y && Z == v.Z;
        }

        /// <summary>判断 XY 是否近似相等（容差 1 个定点数单位，即真实 0.001）</summary>
        public bool ApproximatelyEqual2D(Vector v)
        {
            return Math.Abs(X - v.X) <= 1 && Math.Abs(Y - v.Y) <= 1;
        }

        /// <summary>判断 XYZ 是否近似相等（容差 1 个定点数单位，即真实 0.001）</summary>
        public bool ApproximatelyEqual(Vector v)
        {
            return Math.Abs(X - v.X) <= 1 && Math.Abs(Y - v.Y) <= 1 && Math.Abs(Z - v.Z) <= 1;
        }

        // ==================== 正交 / 拷贝 / 反转 ====================

        /// <summary>返回 XOY 平面上的正交向量（逆时针旋转90度）</summary>
        public Vector Orthogonal2D()
        {
            return new Vector { X = -Y, Y = X, Z = Z };
        }

        /// <summary>深拷贝</summary>
        public Vector Copy()
        {
            return new Vector { X = X, Y = Y, Z = Z };
        }

        /// <summary>拷贝但替换 Z（参数为真实浮点值）</summary>
        public Vector CopyNewZ(double z)
        {
            return new Vector { X = X, Y = Y, Z = FloatToFixed(z) };
        }

        /// <summary>拷贝但替换 Z（参数为定点数值）</summary>
        public Vector CopyNewZInt(long z)
        {
            return new Vector { X = X, Y = Y, Z = z };
        }

        /// <summary>将自身值拷贝到 dst</summary>
        public void CopyTo(Vector dst)
        {
            dst.X = X;
            dst.Y = Y;
            dst.Z = Z;
        }

        /// <summary>返回 XY 取反的向量（Z 不变）</summary>
        public Vector Reverse2D()
        {
            return new Vector { X = -X, Y = -Y, Z = Z };
        }

        /// <summary>返回 XYZ 均取反的向量</summary>
        public Vector Reverse()
        {
            return new Vector { X = -X, Y = -Y, Z = -Z };
        }

        // ==================== 加减乘除 ====================

        /// <summary>二维加法（Z 保持自身值）</summary>
        public Vector Add2D(Vector v)
        {
            return new Vector { X = X + v.X, Y = Y + v.Y, Z = Z };
        }

        /// <summary>三维加法</summary>
        public Vector Add(Vector v)
        {
            return new Vector { X = X + v.X, Y = Y + v.Y, Z = Z + v.Z };
        }

        /// <summary>二维减法（Z 保持自身值）</summary>
        public Vector Sub2D(Vector v)
        {
            return new Vector { X = X - v.X, Y = Y - v.Y, Z = Z };
        }

        /// <summary>三维减法</summary>
        public Vector Sub(Vector v)
        {
            return new Vector { X = X - v.X, Y = Y - v.Y, Z = Z - v.Z };
        }

        /// <summary>二维标量乘法（参数为整数倍率，Z 不变）</summary>
        public Vector Mul2D(long v)
        {
            return new Vector { X = X * v, Y = Y * v, Z = Z };
        }

        /// <summary>三维标量乘法（参数为整数倍率）</summary>
        public Vector Mul(long v)
        {
            return new Vector { X = X * v, Y = Y * v, Z = Z * v };
        }

        /// <summary>二维标量乘以浮点数（Z 不变）</summary>
        public Vector MulFloat2D(double v)
        {
            return new Vector
            {
                X = (long)Math.Round((double)X * v),
                Y = (long)Math.Round((double)Y * v),
                Z = Z
            };
        }

        /// <summary>三维标量乘以浮点数</summary>
        public Vector MulFloat(double v)
        {
            return new Vector
            {
                X = (long)Math.Round((double)X * v),
                Y = (long)Math.Round((double)Y * v),
                Z = (long)Math.Round((double)Z * v)
            };
        }

        /// <summary>二维标量除法（参数为整数倍率，Z 不变，除零返回自身拷贝）</summary>
        public Vector Div2D(long v)
        {
            if (v == 0) return Copy();
            return new Vector { X = X / v, Y = Y / v, Z = Z };
        }

        /// <summary>三维标量除法（参数为整数倍率，除零返回自身拷贝）</summary>
        public Vector Div(long v)
        {
            if (v == 0) return Copy();
            return new Vector { X = X / v, Y = Y / v, Z = Z / v };
        }

        /// <summary>二维标量除以浮点数（Z 不变）</summary>
        public Vector DivFloat2D(double v)
        {
            if (v == 0) return Copy();
            double inv = 1.0 / v;
            return new Vector
            {
                X = (long)Math.Round((double)X * inv),
                Y = (long)Math.Round((double)Y * inv),
                Z = Z
            };
        }

        /// <summary>三维标量除以浮点数</summary>
        public Vector DivFloat(double v)
        {
            if (v == 0) return Copy();
            double inv = 1.0 / v;
            return new Vector
            {
                X = (long)Math.Round((double)X * inv),
                Y = (long)Math.Round((double)Y * inv),
                Z = (long)Math.Round((double)Z * inv)
            };
        }

        // ==================== 归一化 ====================

        /// <summary>返回 XOY 平面的单位向量（定点数表示，长度 = Scale），保留原始 Z 值</summary>
        public Vector Norm2D()
        {
            long lenSq = LengthSq2D();
            if (lenSq == 0)
            {
                return new Vector { X = ForwardVector.X, Y = ForwardVector.Y, Z = Z };
            }
            double l = ScaleF64 / Math.Sqrt((double)lenSq);
            return new Vector
            {
                X = (long)Math.Round((double)X * l),
                Y = (long)Math.Round((double)Y * l),
                Z = Z
            };
        }

        /// <summary>返回三维单位向量（定点数表示，长度 = Scale）</summary>
        public Vector Norm()
        {
            long lenSq = LengthSq();
            if (lenSq == 0) return Copy();
            long scaleSq = Scale * Scale;
            if (lenSq == scaleSq) return Copy();
            double l = ScaleF64 / Math.Sqrt((double)lenSq);
            return new Vector
            {
                X = (long)Math.Round((double)X * l),
                Y = (long)Math.Round((double)Y * l),
                Z = (long)Math.Round((double)Z * l)
            };
        }

        // ==================== 随机 ====================

        /// <summary>在 [min, max] 范围内生成随机向量（参数为定点数向量）</summary>
        public static Vector GenerateRandomVector(Vector min, Vector max)
        {
            return new Vector
            {
                X = (long)(RandomSource.NextDouble() * (double)(max.X - min.X)) + min.X,
                Y = (long)(RandomSource.NextDouble() * (double)(max.Y - min.Y)) + min.Y,
                Z = (long)(RandomSource.NextDouble() * (double)(max.Z - min.Z)) + min.Z
            };
        }

        // ==================== Lerp 插值 ====================

        /// <summary>线性插值，t 为 [0, 1] 的浮点值</summary>
        public Vector Lerp(Vector v, double t)
        {
            return new Vector
            {
                X = X + (long)Math.Round((double)(v.X - X) * t),
                Y = Y + (long)Math.Round((double)(v.Y - Y) * t),
                Z = Z + (long)Math.Round((double)(v.Z - Z) * t)
            };
        }

        /// <summary>二维线性插值（Z 保持自身值）</summary>
        public Vector Lerp2D(Vector v, double t)
        {
            return new Vector
            {
                X = X + (long)Math.Round((double)(v.X - X) * t),
                Y = Y + (long)Math.Round((double)(v.Y - Y) * t),
                Z = Z
            };
        }

        // ==================== MoveTowards ====================

        /// <summary>向目标移动，最大距离为 maxDist（真实浮点值）</summary>
        public Vector MoveTowards(Vector target, double maxDist)
        {
            double dx = (double)(target.X - X);
            double dy = (double)(target.Y - Y);
            double dz = (double)(target.Z - Z);
            double distSq = dx * dx + dy * dy + dz * dz;
            double maxFixed = maxDist * ScaleF64;
            if (distSq == 0 || distSq <= maxFixed * maxFixed)
            {
                return target.Copy();
            }
            double dist = Math.Sqrt(distSq);
            double ratio = maxFixed / dist;
            return new Vector
            {
                X = X + (long)Math.Round(dx * ratio),
                Y = Y + (long)Math.Round(dy * ratio),
                Z = Z + (long)Math.Round(dz * ratio)
            };
        }

        /// <summary>二维向目标移动（Z 保持自身值）</summary>
        public Vector MoveTowards2D(Vector target, double maxDist)
        {
            double dx = (double)(target.X - X);
            double dy = (double)(target.Y - Y);
            double distSq = dx * dx + dy * dy;
            double maxFixed = maxDist * ScaleF64;
            if (distSq == 0 || distSq <= maxFixed * maxFixed)
            {
                return new Vector { X = target.X, Y = target.Y, Z = Z };
            }
            double dist = Math.Sqrt(distSq);
            double ratio = maxFixed / dist;
            return new Vector
            {
                X = X + (long)Math.Round(dx * ratio),
                Y = Y + (long)Math.Round(dy * ratio),
                Z = Z
            };
        }

        // ==================== 便捷方法 ====================

        /// <summary>判断是否为零向量</summary>
        public bool IsZero()
        {
            return X == 0 && Y == 0 && Z == 0;
        }

        /// <summary>判断 XY 是否为零</summary>
        public bool IsZero2D()
        {
            return X == 0 && Y == 0;
        }

        /// <summary>从真实浮点坐标设置（就地修改）</summary>
        public void SetFromFloat64(double x, double y, double z)
        {
            X = FloatToFixed(x);
            Y = FloatToFixed(y);
            Z = FloatToFixed(z);
        }

        /// <summary>分量取最小值</summary>
        public Vector Min(Vector v)
        {
            return new Vector
            {
                X = Math.Min(X, v.X),
                Y = Math.Min(Y, v.Y),
                Z = Math.Min(Z, v.Z)
            };
        }

        /// <summary>分量取最大值</summary>
        public Vector Max(Vector v)
        {
            return new Vector
            {
                X = Math.Max(X, v.X),
                Y = Math.Max(Y, v.Y),
                Z = Math.Max(Z, v.Z)
            };
        }

        /// <summary>将向量分量限制在 [min, max] 范围内</summary>
        public Vector Clamp(Vector minV, Vector maxV)
        {
            return new Vector
            {
                X = Math.Max(minV.X, Math.Min(X, maxV.X)),
                Y = Math.Max(minV.Y, Math.Min(Y, maxV.Y)),
                Z = Math.Max(minV.Z, Math.Min(Z, maxV.Z))
            };
        }
    }
}
`

	return os.WriteFile(path, []byte(content), 0644)
}
