package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
)

// EKeyInfo holds information about an EKey enum value
type EKeyInfo struct {
	Name  string
	Value int32
}

// GenerateGo generates Go code
func GenerateGo(cfg *Config) error {
	// Parse proto files
	enumMap, err := parseEKeyEnum(filepath.Join(cfg.ProtoDir, "cmd.proto"))
	if err != nil {
		return fmt.Errorf("parse cmd.proto: %w", err)
	}

	reqMessages, err := parseMessages(filepath.Join(cfg.ProtoDir, "cmd_req.proto"))
	if err != nil {
		return fmt.Errorf("parse cmd_req.proto: %w", err)
	}

	rspMessages, err := parseMessages(filepath.Join(cfg.ProtoDir, "cmd_rsp.proto"))
	if err != nil {
		return fmt.Errorf("parse cmd_rsp.proto: %w", err)
	}

	dspMessages, err := parseMessages(filepath.Join(cfg.ProtoDir, "cmd_dsp.proto"))
	if err != nil {
		return fmt.Errorf("parse cmd_dsp.proto: %w", err)
	}

	// Generate Go files using protoc
	if err := generateProtocGo(cfg); err != nil {
		return fmt.Errorf("protoc: %w", err)
	}

	// Generate cmd.ext.go
	outputPath := filepath.Join(cfg.GoOutDir, "cmd.ext.go")
	if err := writeGoCmdExt(outputPath, enumMap, reqMessages, rspMessages, dspMessages); err != nil {
		return fmt.Errorf("write cmd.ext.go: %w", err)
	}

	fmt.Printf("Generated: %s\n", outputPath)
	return nil
}

// generateProtocGo runs protoc to generate Go files
func generateProtocGo(cfg *Config) error {
	args := []string{
		"--go_out=" + cfg.GoOutDir,
		"--go_opt=paths=source_relative",
		fmt.Sprintf("--go_opt=Mpackage=%s", cfg.GoPkg),
		fmt.Sprintf("--plugin=protoc-gen-go=%s", cfg.ProtocGenGo),
		"-I" + cfg.ProtoDir,
		"-I" + cfg.GoOutDir,
	}

	protoFiles, err := filepath.Glob(filepath.Join(cfg.ProtoDir, "*.proto"))
	if err != nil {
		return fmt.Errorf("list proto files: %w", err)
	}

	args = append(args, protoFiles...)

	cmd := exec.Command(cfg.ProtocPath, args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	fmt.Printf("Running: %s %s\n", cfg.ProtocPath, strings.Join(args, " "))

	return cmd.Run()
}

// writeGoCmdExt generates cmd.ext.go for Go
func writeGoCmdExt(path string, enumMap map[int32]EKeyInfo, reqMessages, rspMessages, dspMessages []string) error {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by pbgen. DO NOT EDIT.\n")
	buf.WriteString("// source: cmd.proto, cmd_req.proto, cmd_rsp.proto, cmd_dsp.proto\n\n")
	buf.WriteString("package pb\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"genpb/pb\"\n\n")
	buf.WriteString("\t\"google.golang.org/protobuf/proto\"\n")
	buf.WriteString("\t\"google.golang.org/protobuf/reflect/protoreflect\"\n")
	buf.WriteString(")\n\n")

	// Global parser instance
	buf.WriteString("var _parser = NewParser()\n\n")
	buf.WriteString("func init() {\n")
	buf.WriteString("\t_parser.Load()\n")
	buf.WriteString("}\n\n")
	buf.WriteString("func Unmarshal(key EKey_T, data []byte) proto.Message {\n")
	buf.WriteString("\treturn _parser.Unmarshal(key, data)\n")
	buf.WriteString("}\n\n")

	// Parser struct
	buf.WriteString("// parser handles protobuf message parsing by EKey\n")
	buf.WriteString("type parser struct {\n")
	buf.WriteString("\ttypes map[EKey_T]protoreflect.Type\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// NewParser creates a new Parser instance\n")
	buf.WriteString("func NewParser() *parser {\n")
	buf.WriteString("\treturn &parser{\n")
	buf.WriteString("\t\ttypes: make(map[EKey_T]protoreflect.Type),\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// Register registers a message type for a given EKey\n")
	buf.WriteString("func (p *parser) Register(key EKey_T, msg proto.Message) {\n")
	buf.WriteString("\tp.types[key] = msg.ProtoReflect().Type()\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// GetType returns the message type for the given EKey\n")
	buf.WriteString("func (p *parser) GetType(key EKey_T) (protoreflect.Type, bool) {\n")
	buf.WriteString("\ttyp, ok := p.types[key]\n")
	buf.WriteString("\treturn typ, ok\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// New creates a new message instance for the given EKey\n")
	buf.WriteString("func (p *parser) New(key EKey_T) proto.Message {\n")
	buf.WriteString("\ttyp, ok := p.GetType(key)\n")
	buf.WriteString("\tif !ok {\n")
	buf.WriteString("\t\treturn nil\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn proto.New(typ).Interface()\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// Unmarshal unmarshals binary data into a new message instance\n")
	buf.WriteString("func (p *parser) Unmarshal(key EKey_T, data []byte) proto.Message {\n")
	buf.WriteString("\tmsg := p.New(key)\n")
	buf.WriteString("\tif msg == nil {\n")
	buf.WriteString("\t\treturn nil\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tif err := proto.Unmarshal(data, msg); err != nil {\n")
	buf.WriteString("\t\treturn nil\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn msg\n")
	buf.WriteString("}\n\n")

	// Load method
	buf.WriteString("// Load registers all message types\n")
	buf.WriteString("func (p *parser) Load() {\n")

	// Client-to-Server requests
	for _, msgName := range reqMessages {
		enumName := strings.TrimPrefix(msgName, "Req")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("\tp.Register(EKey_%s, &%s{})\n", info.Name, msgName))
				break
			}
		}
	}

	// Server-to-Client responses
	for _, msgName := range rspMessages {
		if strings.HasPrefix(msgName, "RspSync") {
			continue
		}
		enumName := strings.TrimPrefix(msgName, "Rsp")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("\tp.Register(EKey_%s, &%s{})\n", info.Name, msgName))
				break
			}
		}
	}

	// Server dispatch/sync messages
	for _, msgName := range dspMessages {
		if !strings.HasPrefix(msgName, "RspSync") {
			continue
		}
		// enumName = "Sync" + name after "RspSync"
		enumName := "Sync" + strings.TrimPrefix(msgName, "RspSync")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("\tp.Register(EKey_%s, &%s{})\n", info.Name, msgName))
				break
			}
		}
	}

	buf.WriteString("}\n\n")

	// Generate Key() methods for all messages
	// Client-to-Server requests
	for _, msgName := range reqMessages {
		enumName := strings.TrimPrefix(msgName, "Req")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("func (msg *%s) Key() pb.EKey {\n", msgName))
				buf.WriteString(fmt.Sprintf("\treturn pb.EKey_%s\n", info.Name))
				buf.WriteString("}\n\n")
				break
			}
		}
	}

	// Server-to-Client responses
	for _, msgName := range rspMessages {
		enumName := strings.TrimPrefix(msgName, "Rsp")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("func (msg *%s) Key() pb.EKey {\n", msgName))
				buf.WriteString(fmt.Sprintf("\treturn pb.EKey_%s\n", info.Name))
				buf.WriteString("}\n\n")
				break
			}
		}
	}

	// Server dispatch/sync messages
	for _, msgName := range dspMessages {
		if !strings.HasPrefix(msgName, "RspSync") {
			continue
		}
		// enumName = "Sync" + name after "RspSync"
		enumName := "Sync" + strings.TrimPrefix(msgName, "RspSync")
		for _, info := range enumMap {
			if info.Name == enumName {
				buf.WriteString(fmt.Sprintf("func (msg *%s) Key() pb.EKey {\n", msgName))
				buf.WriteString(fmt.Sprintf("\treturn pb.EKey_%s\n", info.Name))
				buf.WriteString("}\n\n")
				break
			}
		}
	}

	return os.WriteFile(path, buf.Bytes(), 0644)
}

// parseEKeyEnum parses cmd.proto to extract EKey enum values
func parseEKeyEnum(path string) (map[int32]EKeyInfo, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	result := make(map[int32]EKeyInfo)
	pattern := regexp.MustCompile(`(\w+)\s*=\s*(\d+)\s*;`)
	matches := pattern.FindAllStringSubmatch(string(content), -1)

	for _, match := range matches {
		if len(match) == 3 {
			name := match[1]
			var value int32
			fmt.Sscanf(match[2], "%d", &value)
			result[value] = EKeyInfo{Name: name, Value: value}
		}
	}

	return result, nil
}

// parseMessages parses a proto file to extract message names
func parseMessages(path string) ([]string, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var messages []string
	pattern := regexp.MustCompile(`message\s+(\w+)\s*\{`)
	matches := pattern.FindAllStringSubmatch(string(content), -1)

	for _, match := range matches {
		if len(match) == 2 {
			messages = append(messages, match[1])
		}
	}

	return messages, nil
}
